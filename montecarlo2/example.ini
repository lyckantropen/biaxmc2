[lattice]
#lattice longitude
L=16		
#lattice width
W=16
#lattice height
H=16
[hamiltonian]
#lambda coupling constant
lambda=0.2
#tau coupling constant
tau=1
#temperature
temperature=1.0
#external second-order field along z
h=0
[simulation]
#number of total production cycles
production_cycles=10000
#number of cycles to skip between measurements. Must be non-zero.
measure_frequency=10
#thermalization cycles
thermalization_cycles=10000
#number of thermalization cycles when the final state of previous simulation is passed as an initial state to the new simulation
supplementary_thermalization_cycles=10000
#interval between 4-sphere random walk radius adjustments
radius_adjustment_frequency=100
#look for an already thermalized state in the database
find_thermalized=yes
#the search can be temperature-tolerant. in units of scanning.delta
find_thermalized_temperature_tolerance=0
#the search can be field-tolerant. in units of field
find_thermalized_field_tolerance=0
[sqlite]
#database file
file=base.db
#database directory
dir=base.db.dir
[output]
#save all intermediate lattices (large database entry - can cause aborts)
save_configuration_evolution=no
#save final lattice
save_final_configuration=yes
#save mean final values
save_final_properties=yes
#save all measured data (can cause aborts if production is very long)
save_properties_evolution=no
#save intermediate lattices
save_intermediate_states=yes
#number of intermediate states to save
save_intermediate_states=10
[initial]
#the initial state is biaxial
biaxial=no
#the initial state is chiral
righthanded=no
#the inisital state is isotropic
isotropic=yes
[scanning]
#whether to enable scanning
enabled=yes
#name of the variable to scan
variable=hamiltonian.temperature
#starting value
start=1.0
#end value
end=1.5
#interval
delta=0.1
#skip thermalization if a thermalized state is found for specific parameters
reuse_thermalized=yes
#calculate many points at once, using parallel computing. same as running many separate non-threaded simulations
threaded=no
#split production between processes - better approach. the scanning is consecutive and the states are passed over to the next simulation
threaded_production=yes
#skip the simulation if results already exist
continue_if_results_exist=yes
[openmp]
#number of parallel threads
number_of_threads=4
#dynamic mode detects the available number of processors and adjusts the number of threads. non-dynamic mode forces the number of threads to number_of_threads
dynamic=no
[project]
#project name to distinguish between subsequent simulations when using the same database
name_format=project
